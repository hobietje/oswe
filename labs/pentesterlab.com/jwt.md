# JSON Web Token

[RFC7519](https://tools.ietf.org/html/rfc7519)

[IANA Assignments: JSON Web Token (JWT)](https://www.iana.org/assignments/jwt/jwt.xhtml#claims)

JWT _can_ provide the following security mechanisms:

* Encryption.
* Signature.

JWTs follow the following pattern:

    Base64(Header).Base64(Data).Base64(Signature)

The header is a JSON object, for example, the header `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9` contains the following information:

```json
{ "alg": "HS256", 
  "typ": "JWS"}
```

The data is similarly a JSON object with any 'claims' appropriate for the application.

```json
{ "loggedInAs":"admin",
  "iat":1422779638 }
```

The signature is calculated by base64url encoding the header and payload and concatenating them with a period as a separator.  For example:

```js
key = 'secretkey'
unsignedToken = encodeBase64(header) + '.' + encodeBase64(payload)
signature = HMAC-SHA256(key, unsignedToken)
```

You can easily decode and encode most JWTs with [jwt.io](https://jwt.io/#debugger-io).

# Information Disclosure

Because the payload is transmitted in plaintext, information leakage occurs if there is sensitive information in the payload.

# Ignored Signatures

JWTs include a signature, but nothing guarantees the back-end code is actually bothering to check and validate this signature.

# Replace Signatures

The JWT header is signed.  JWT supports multiple algorithms for signatures, so first we need to determine what algorithm was used to generate the signature. There's an `alg` field in the header that tells us just that. But we haven't validated integrity of the header yet, so how can we be sure the `alg` field hasn't been tampered with (and the signature updated to match)?

## Change to 'none' algorithm

The `none` algorithm is intended to be used for [unsecured JWTs](https://tools.ietf.org/html/rfc7519#section-6.1), e.g. for situations where the integrity of the token has already been verified.  It is one of two algorithms that are mandatory to implement (the other being HS256).

Some libraries treated tokens signed with the `none` algorithm as a valid token with a verified signature.

An attacker can thus change the header to have `"alg": "none"` and use a blank signature.

## Change 'RS256' to 'HS256' algorithm

The algorithm RS256 uses a private key to sign messages, and a public key to verify them.

If we change the algorithm to HS256, we can sign a JWT with the public key, since the public key is not secret at all.

_In most real-life scenarios, there is still an assumption that an attacker can actually obtain the public key!_

Because the server uses the `alg` data from the JWT token itself, it typically only has code - similar to the example below — that only uses the expected public key to validate a token but doesn't specify the algorithm to expect.

`jwt = JWT.decode(token, public_key)`

Because we changed the algoritm to be symmetric, using the same key to sign and verity, we can thus self-sign our token using HS256.

_The trickiest part is making sure that `public_key` value is identical to the verification key used on the server. The strings must match exactly for the attack to work -- exact same format, and no extra or missing line breaks._

# Poor Signature Secrets

## Empty Secrets

The signature secret is a string with no limits or restrictions implemented by design.  As a result, developers often keep it blank, or might forget to configure it correctly!

## Defaults / Examples

Developer code code found on the Internet.  It's a thing!

Wallarm found as many public JWT secrets as possible, using Google search and GitHub dorks, to generated a [list of public JWT secrets](https://github.com/wallarm/jwt-secrets).  A Burp Suite Extension called [jwt-heartbreaker](https://github.com/wallarm/jwt-heartbreaker) is available to check any JWTs discovered.

## Brute-Force the HS256

A problem with JWT signatures is that attackers can offline brute-force secrets by using only a JWT sample.

* [jwtbrute](https://github.com/jmaxxz/jwtbrute)
* [crackjwt.py](https://github.com/Sjord/jwtcrack/blob/master/crackjwt.py) using [PyJWT](https://github.com/jpadilla/pyjwt)
* [John the Ripper](https://github.com/magnumripper/JohnTheRipper)

You can then create a new JWT with any payload you want and sign it.

# JOSE Header

[IANA Assignments: JSON Object Signing and Encryption (JOSE)](https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-header-parameters)

## "typ" (Type) Header Parameter

## "cty" (Content Type) Header Parameter

## "kid" (Key ID)

The `kid` specifies the key that was used to sign this token and hence which key should be used for verification.

In some cases, we may be able to inject values in the `kid` without bothering to resign the JWT.  Flaws in the parsing logic may lead to:
* The `kid` may be used to lookup a secret from a DB or file on disk.  As we can tamper with it, it may be possible to get:
  * RCE, e.g. `"kid":"|nc..."`
  * SQLi
  * etc

In other cases, we can resign the JWT but with a key of our choosing, for example:
  * With LFI, it may be possible to choose a different public key file to validate the signature with, e.g. use an "empty" key with `"kid": "/dev/null"`

# Registered Claim Names

## "iss" (Issuer) Claim

Identifies the principal that issued the JWT.

* Code should validate that the Issuer is a known, current, expected creator of JWT tokens.

## "sub" (Subject) Claim

Identifies the principal that is the subject of the JWT.  If used:

* The subject value MUST either be scoped to be locally unique in the context of the issuer, or be globally unique.
* The processing of this claim is generally application specific, so investigate code paths to see how and where this is used and may be vulnerable.

## "aud" (Audience) Claim

Identifies the recipients that the JWT is intended for.  

* Code should validate that tokens received are for the current resource server.  I.e. tokens for one resource server should not be ale to be used on another resource server.

## "exp" (Expiration Time) Claim

Identifies the expiration time on or after which the JWT MUST NOT be accepted for processing.

* Validate that the server is checking the expiration time of tokens
* Validate that the clock on the server is correct and only a small amount of clock skew is permitted.

## "nbf" (Not Before) Claim

Identifies the time before which the JWT MUST NOT be accepted for processing.

If used:

* ensure the server ignores tokens until this time has passed.

## iat" (Issued At) Claim

Identifies the time at which the JWT was issued.

If used:

* check the code to see if any meaning is (incorrectly?) assigned to this value.  E.g. is it used as a poor alternative to `nbf` or `exp` tokens?

## "jti" (JWT ID) Claim

Provides a unique identifier for the JWT.

* Validate that the `jti` values are sufficiently random. There should be a negligible probability that the same value will be accidentally assigned to a different JWT.
* Check what the `jti` is used for.  Commonly this is used to be able to revoke access to JWT's that haven't yet expired.  Validate those processes work correctly and cannot be abused or circumvented.

# JSON Web Encryption (JWE)

[RFC7516](https://tools.ietf.org/html/rfc7516)

TODO

In some applications using encrypted JWTs, it is useful to have an unencrypted representation of some claims and replicate them between the payload and headers. 

* If such replicated claims are present, the
   application receiving them SHOULD verify that their values are
   identical, unless the application defines other specific processing
   rules for these claims.
* Should verify that this information is not in any way sensitive, i.e. information disclosure.

# JSON Web Signature (JWS)

[RFC7515](https://tools.ietf.org/html/rfc7515)

__Use PS256 or RS256 with a JWK embedded within the JWT header__

[CVE-2018-0114](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0114)

JSON Web Signature (JWS) specifies that a JSON Web Key (JWK) representing a public key can be embedded within the header of a JWS. This public key is then trusted for verification. 

An attacker could exploit this by forging valid JWS objects by removing the original signature, adding a new public key to the header, and then signing the object using the (attacker-owned) private key associated with the public key embedded in that JWS header.

The public key used for verifying the token is provided in the header part of the token, namely the `n` and `e` parameters of the RSA algorithm.  Both n and e are transmitted as hexadecimal string values.

Examples:

* [lab](https://attackdefense.com/challengedetailsnoauth?cid=1402) consisting of a target machine hosting Strapi CMS on port 1337. The CMS uses the JWT token library vulnerable to the CVE-2018–0114.  See [write-up](https://blog.pentesteracademy.com/hacking-jwt-tokens-jws-standard-for-jwt-666810809323).

# JWK Set URL (JKU)

JKU allows a JWT token to specify the url of a HTTP GET accessible resource that provides one or more JWK values encoded as a JWK Set.

```
GET https://example.com/.well-known/jwks.json
{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "mykey",
      "n": "oTtAXRgdJ6Pu0jr3hK3opCF5uqKWKbm4KkqIiDJSEsQ4PnAz14P_aJnfnsQwgchFGN95cfCO7euC8HjT-u5WHHDn08GQ7ot6Gq6j-fbwMdRWjLC74XqQ0JNDHRJoM4bbj4i8FaBdYKvKmnJ8eSeEjA0YrG8KuTOPbLsglADUubNw9kggRIvj6au88dnBJ9HeZ27QVVFaIllZpMITtocuPkOKd8bHzkZzKN4HJtM0hgzOjeyCfqZxh1V8LybliWDXYivUqmvrzchzwXTAQPJBBfYo9BO6D4Neui8rGbc49OBCnHLCWtPH7m7xp3cz-PbVnLhRczzsQE_3escvTF0FGw",
      "e": "AQAB",
      "alg": "RS256"
    }
  ]
}
```

__Change signature type to PS256 with a JWK embedded within the JWT header__

As an attacker, we can provide our own URL publishing the JWK for our public key and sign the message using the corresponding private key.
