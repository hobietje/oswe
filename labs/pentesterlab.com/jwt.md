# JSON Web Token

[RFC7519](https://tools.ietf.org/html/rfc7519)

[IANA Assignments: JSON Web Token (JWT)](https://www.iana.org/assignments/jwt/jwt.xhtml#claims)

JWT _can_ provide the following security mechanisms:

* Encryption.
* Signature.

JWTs follow the following pattern:

    Base64(Header).Base64(Data).Base64(Signature)

The header is a JSON object, for example, the header `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXUyJ9` contains the following information:

```json
{ "alg": "HS256", 
  "typ": "JWS"}
```

The data is similarly a JSON object with any 'claims' appropriate for the application.

```json
{ "loggedInAs":"admin",
  "iat":1422779638 }
```

The signature is calculated by base64url encoding the header and payload and concatenating them with a period as a separator.  For example:

```js
key = 'secretkey'
unsignedToken = encodeBase64(header) + '.' + encodeBase64(payload)
signature = HMAC-SHA256(key, unsignedToken)
```

You can easily decode and encode most JWTs with [jwt.io](https://jwt.io/#debugger-io).

# Information Disclosure

Because the payload is transmitted in plaintext, information leakage occurs if there is sensitive information in the payload.

# Ignored Signatures

JWTs include a signature, but nothing guarantees the back-end code is actually bothering to check and validate this signature.

# Replace Signatures

The JWT header is signed.  JWT supports multiple algorithms for signatures, so first we need to determine what algorithm was used to generate the signature. There's an `alg` field in the header that tells us just that. But we haven't validated integrity of the header yet, so how can we be sure the `alg` field hasn't been tampered with (and the signature updated to match)?

## Change to 'none' algorithm

[How many days since a JWT alg=None vulnerability](https://www.howmanydayssinceajwtalgnonevuln.com/)

The `none` algorithm is intended to be used for [unsecured JWTs](https://tools.ietf.org/html/rfc7519#section-6.1), e.g. for situations where the integrity of the token has already been verified.  It is one of two algorithms that are mandatory to implement (the other being HS256).

Some libraries treated tokens signed with the `none` algorithm as a valid token with a verified signature.

An attacker can thus change the header to have `"alg": "none"` and use a blank signature.

## Change 'RS256' to 'HS256' algorithm

The algorithm `RS256` uses a private key to sign messages, and a public key to verify them.   Because the `alg` is provided in the JWT itself, we can easily replace it with the symmetric `HS256` algorithm and sign the token with the RS256 public key instead.  As this RS256 public key is also used for validation, we should thus be able to create arbitrary valid tokens.

### With known public key

While the public key is not required to be kept secret at all, in most real-life scenarios however, there is still an assumption that an attacker has access to the public key.

If we do have access to the public key, we simply change the algoritm to be `HS256` symmetric and use the same public key to sign and verify the JWT token.

_The trickiest part is making sure that `public_key` value is identical to the verification key used on the server. The strings must match exactly for the attack to work -- exact same format, and no extra or missing line breaks._

### With key confusion

In practice, the public key is rarely available (at least in a black-box setting), so we may need to resolve to some algebra.

Public key cryptosystems guarantee that the private key can’t be derived from the public key, signatures, ciphertexts, etc, however there are usually no such guarantees for the public key.  In essense:

* An RSA public key is an `(n,e)` pair of integers, where `n` is the modulus and `e` is the public exponent. Since `e` is usually some hardcoded small number (`e=3` being one of the most popular), we typically only need to put effort in finding `n`.
* Although RSA involves large numbers, really efficient algorithms exist to find the GCD of numbers since the ancient times (we don’t have to do brute-force factoring). We can thus find the greatest common divisor (GCD) of the difference of all available message-signature pairs.
* Although the presented method is probabilistic, in practice we can usually just try all possible answers. Additionally, our chances grow with the number of known message-signature pairs.

Because PKCS #1 and PEM allow little to no room for changes or other flexibility, there is a high chance that we can generate a standards compliant PEM file that will match the one at the target exactly.  However:
* The server needs to have its keys in the same format we generate.  Information disclosure vulnerabilities that expose the coding language or JWT library used can help identify supported key formats.
* If key files contain additional, unpredictable data, it is unlikely that we can reconstruct the key.

Full write-up at [CVE-2017-11424](https://blog.silentsignal.eu/2021/02/08/abusing-jwt-public-keys-without-the-public-key/) for pyJWT vulnerability with [fix](https://github.com/jpadilla/pyjwt/pull/277).  Also in node-jwt-simple as per [CVE-2016-10555](https://github.com/silentsignal/rsa_sign2n/tree/release/CVE-2016-10555).  In essense:

* We run the GCD algorithm in [gmpy2](https://pypi.org/project/gmpy2/) on two signatures.  The algorithm produces a number of candidate keys for PKCS #1 which can be tested.
* We generate the PEM for the given keys using [asn1tools](https://asn1tools.readthedocs.io/en/latest/)
* We forge and sign JWT tokens with these keys and submit them to the target for testing.

TODO: [RSA CTF](http://ratmirkarabut.com/articles/ctf-writeup-google-ctf-quals-2017-rsa-ctf-challenge/)
TODO: [ASN.1 key structures in DER and PEM](https://tls.mbed.org/kb/cryptography/asn1-key-structures-in-der-and-pem)

# Poor Signature Secrets

## Empty Secrets

The signature secret is a string with no limits or restrictions implemented by design.  As a result, developers often keep it blank, or might forget to configure it correctly!

## Defaults / Examples

Developer code code found on the Internet.  It's a thing!

Wallarm found as many public JWT secrets as possible, using Google search and GitHub dorks, to generated a [list of public JWT secrets](https://github.com/wallarm/jwt-secrets).  A Burp Suite Extension called [jwt-heartbreaker](https://github.com/wallarm/jwt-heartbreaker) is available to check any JWTs discovered.

## Brute-Force the HS256

A problem with JWT signatures is that attackers can offline brute-force secrets by using only a JWT sample.

* [jwtbrute](https://github.com/jmaxxz/jwtbrute)
* [crackjwt.py](https://github.com/Sjord/jwtcrack/blob/master/crackjwt.py) using [PyJWT](https://github.com/jpadilla/pyjwt)
* [John the Ripper](https://github.com/magnumripper/JohnTheRipper)

You can then create a new JWT with any payload you want and sign it.

# JOSE Header

[IANA Assignments: JSON Object Signing and Encryption (JOSE)](https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-header-parameters)

## "typ" (Type) Header Parameter

## "cty" (Content Type) Header Parameter

## "kid" (Key ID)

The `kid` specifies the key that was used to sign this token and hence which key should be used for verification.

In some cases, we may be able to inject values in the `kid` without bothering to resign the JWT.  Flaws in the parsing logic may lead to:
* The `kid` may be used to lookup a secret from a DB or file on disk.  As we can tamper with it, it may be possible to get:
  * RCE, e.g. `"kid":"|nc..."`
  * SQLi
  * etc

In other cases, we can resign the JWT but with a key of our choosing, for example:
  * With LFI, it may be possible to choose a different public key file to validate the signature with, e.g. use an "empty" key with `"kid": "/dev/null"`

# Registered Claim Names

## "iss" (Issuer) Claim

Identifies the principal that issued the JWT.

* Code should validate that the Issuer is a known, current, expected creator of JWT tokens.

## "sub" (Subject) Claim

Identifies the principal that is the subject of the JWT.  If used:

* The subject value MUST either be scoped to be locally unique in the context of the issuer, or be globally unique.
* The processing of this claim is generally application specific, so investigate code paths to see how and where this is used and may be vulnerable.

## "aud" (Audience) Claim

Identifies the recipients that the JWT is intended for.  

* Code should validate that tokens received are for the current resource server.  I.e. tokens for one resource server should not be ale to be used on another resource server.

## "exp" (Expiration Time) Claim

Identifies the expiration time on or after which the JWT MUST NOT be accepted for processing.

* Validate that the server is checking the expiration time of tokens
* Validate that the clock on the server is correct and only a small amount of clock skew is permitted.

## "nbf" (Not Before) Claim

Identifies the time before which the JWT MUST NOT be accepted for processing.

If used:

* ensure the server ignores tokens until this time has passed.

## iat" (Issued At) Claim

Identifies the time at which the JWT was issued.

If used:

* check the code to see if any meaning is (incorrectly?) assigned to this value.  E.g. is it used as a poor alternative to `nbf` or `exp` tokens?

## "jti" (JWT ID) Claim

Provides a unique identifier for the JWT.

* Validate that the `jti` values are sufficiently random. There should be a negligible probability that the same value will be accidentally assigned to a different JWT.
* Check what the `jti` is used for.  Commonly this is used to be able to revoke access to JWT's that haven't yet expired.  Validate those processes work correctly and cannot be abused or circumvented.

# JSON Web Encryption (JWE)

[RFC7516](https://tools.ietf.org/html/rfc7516)

TODO

In some applications using encrypted JWTs, it is useful to have an unencrypted representation of some claims and replicate them between the payload and headers. 

* If such replicated claims are present, the
   application receiving them SHOULD verify that their values are
   identical, unless the application defines other specific processing
   rules for these claims.
* Should verify that this information is not in any way sensitive, i.e. information disclosure.

# JSON Web Signature (JWS)

[RFC7515](https://tools.ietf.org/html/rfc7515)

__Use PS256 or RS256 with a JWK embedded within the JWT header__

[CVE-2018-0114](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0114)

JSON Web Signature (JWS) specifies that a JSON Web Key (JWK) representing a public key can be embedded within the header of a JWS. This public key is then trusted for verification. 

An attacker could exploit this by forging valid JWS objects by removing the original signature, adding a new public key to the header, and then signing the object using the (attacker-owned) private key associated with the public key embedded in that JWS header.

The public key used for verifying the token is provided in the header part of the token, namely the `n` and `e` parameters of the RSA algorithm.  Both n and e are transmitted as hexadecimal string values.

Examples:

* [lab](https://attackdefense.com/challengedetailsnoauth?cid=1402) consisting of a target machine hosting Strapi CMS on port 1337. The CMS uses the JWT token library vulnerable to the CVE-2018–0114.  See [write-up](https://blog.pentesteracademy.com/hacking-jwt-tokens-jws-standard-for-jwt-666810809323).

# JWK Set URL (JKU)

JKU allows a JWT token to specify the url of a HTTP GET accessible resource that provides one or more JWK values encoded as a JWK Set.

```
GET https://example.com/.well-known/jwks.json
{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "mykey",
      "n": "oTtAXRgdJ6Pu0jr3hK3opCF5uqKWKbm4KkqIiDJSEsQ4PnAz14P_aJnfnsQwgchFGN95cfCO7euC8HjT-u5WHHDn08GQ7ot6Gq6j-fbwMdRWjLC74XqQ0JNDHRJoM4bbj4i8FaBdYKvKmnJ8eSeEjA0YrG8KuTOPbLsglADUubNw9kggRIvj6au88dnBJ9HeZ27QVVFaIllZpMITtocuPkOKd8bHzkZzKN4HJtM0hgzOjeyCfqZxh1V8LybliWDXYivUqmvrzchzwXTAQPJBBfYo9BO6D4Neui8rGbc49OBCnHLCWtPH7m7xp3cz-PbVnLhRczzsQE_3escvTF0FGw",
      "e": "AQAB",
      "alg": "RS256"
    }
  ]
}
```

__Change signature type to PS256 with a JWK embedded within the JWT header__

As an attacker, we can provide our own URL publishing the JWK for our public key and sign the message using the corresponding private key.
